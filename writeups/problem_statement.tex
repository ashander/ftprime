\documentclass[12pt]{article}
\usepackage[inline]{asymptote}

\title{recording msprime `coalescence records' from forward time simulations}
\author{Jaime Ashander}
\date{}
\begin{document}
\maketitle

\begin{asydef}
//
// Global Asymptote definitions
//
usepackage("bm");
texpreamble("\def\V#1{\bm{#1}}");
\end{asydef}

{\bf Goal} Our goal is to encode the ARG produced  from a simulation that
proceeds forward in time in {\tt msprime}-style coalesence records.
One way to do this is to simulate forward, sample, and then work backwards.
In theory, one could also produce "partial'' records going forward.
Up to present, this is what we have done --- producing records as described in
{\it Going forward} below and augmenting any singleton remaining with a
``phantom'' sibling (all having the same ID.
These can be loaded in to {\tt msprime} but don't actually meet the specs ---
there are many redundant trees encoded.
It seems that to meet {\tt msprime} format requirements we will still need to
traverse backward from a given set of samples to prune off incomplete records.

{ \bf A scenario}
Below each chromosome is labeled on the left with an ID; a single breakpoint,
labelled below the chromosome, represents a recombination during the meiosis
that produced the chromosome.
Above, the haplotypes are labelled by the ID for the parent that produced them.

Consider a lineage descended from three parent chromosomes: $1,2,3$.
Mating between these produced a first generation of two individuals
$(4,6)$ and $(5,7)$.
A subsequent mating between these produced gametes $8$ and $9$ in the second generation.

\begin{center}
	\begin{asy}[width=\the\linewidth,inline=true]
		// positioning info
		real g0 = 0;
		real g1 = -0.2;
		real g1b = -0.325;
		real g2 = -.6;
		real col0 = 0.5;
		real col1 = 1.5;
		real chromlen = 0.5;
		pair l = (chromlen, 0);
//		pair final = (0, -.5);

		//chromosome labels
		pair[] n;
		n[1] = (0, g0);
		n[2] = (1, g0);
		n[3] = (2, g0);
		// gen1
		n[4] = (col0, g1);
		n[5] = (col1, g1);
		n[6] = (col0, g1b);
		n[7] = (col1, g1b);
		// gen2
		n[8] = (col0, g2);
		n[9] = (col1, g2);

		//breakpoints
		pair bpmark = (0, 0.025); // formatting mark
		pair[] bp;
		bp[4] = (0.5 * chromlen, 0);
		bp[5] = (0.25 * chromlen, 0);
		bp[6] = (0.0 * chromlen, 0);
		bp[7] = (0.0 * chromlen, 0);
		bp[8] = (0.75 * chromlen, 0);
		bp[9] = (0.3 * chromlen, 0);

		//parents
		pair rightfmt = (.05, .025);
		pair leftfmt = (-.05, .025);
		pair[] parents;
		parents[4] = (1, 2);
		parents[5] = (3, 2);
		parents[6] = (0, 2);
		parents[7] = (0, 3);
		parents[8] = (5, 6);
		parents[9] = (7, 6);

		for (int i = 1; i <= 3; ++i) {
			dot(format("$%d$", i), n[i], W);
			draw(n[i]--l + n[i]);
		}
		pair parent;
		pair bploc;
		for (int i = 4; i <= 9; ++i) {
			dot(format("$%d$", i), n[i], W);
			draw(n[i]--l + n[i]);
			bploc = bp[i] + n[i];
			draw(bploc--bploc + bpmark);
			label(format("$x_%d$", i), bploc, S);
			parent = parents[i];
			label(format("$%f$", parent.y), bploc + bpmark + rightfmt);
			if (parent.x != 0.0) {
				label(format("$%f$", parent.x), bploc + bpmark + leftfmt);
			}

		}
//		pair endline = (0, g2)  + (0, -0.25);
//		draw(endline--endline +(3, 0));
//		int idx;
//		for (int i=8; i <=9; ++i) {
//			dot(format("$%d$", i), n[i] + final, W);
//			draw(n[i] + final--final + l + n[i]);
//			//self
//			bploc = bp[i] + n[i] + final;
//			draw(bploc--bploc + bpmark);
//			label(format("$x_%d$", i), bploc, N);
//
//			parent = parents[i];
//			//l parent
//			idx = (int) parent.x;
//			bploc = bploc = bp[idx] + n[i] + final;
//			draw(bploc--bploc + bpmark);
//			label(format("$x_%d$", (int) parent.x), bploc, S);
//
//			//r parent
//			idx = (int) parent.y;
//			bploc = bploc = bp[idx] + n[i] + final;
//			draw(bploc--bploc + bpmark);
//			label(format("$x_%d$", (int) parent.y), bploc, N);
//		}
	\end{asy}
\end{center}

% All the accumulated recombination breakpoints are labelled on these final gametes, below the large horizonal line.

We describe coalescence records in the format $(left, right, node, (children), time)$ of {\tt msprime}.
Label the right endpoint of the chromosome by $L$ and the left by $0.0$.
Further, label the current generation $0$, the parent $-1$ and the grandparent $-2$.
Below, I refer a pair (or more) combining backwards in time as ``coalescence''
and a haplotype finding itt parent but not coalescing with another as a
``singleton".

\subsection*{Going forward}
We could imagine constructing something like the records going forward in time.
Each meiosis provides some information (not all of it ultimately useful).

In the grandparent generation, there is one singleton coalescence to $1$:
\begin{verbatim}
	A = (0, x_4, 1, (4, ), -2)
\end{verbatim}
two different coalescence to $2$ and a singleton left over:
\begin{verbatim}
	B = (0, x_5, 2, (6, ), -2)
	C = (x_5, x_4,  2, (5, 6), -2)
	D = (x_4, L,  2, (4, 5, 6), -2)
\end{verbatim}
and one coalescence to $3$ with one singleton left:
\begin{verbatim}
	E = (0, x_5, 3, (5, 7), -2)
	F = (x_5, L, 3, (7, ), -2)
\end{verbatim}

In the parent generation, there is one coalescence to $6$:
\begin{verbatim}
	G = (x_8, L,  6, (8, 9), -1)
\end{verbatim}
and some singletons:
\begin{verbatim}
	H = (0, x_8, 5, (8, ), -1)
	I = (0, x_9, 7, (9, ), -1)
	J = (x_9, x_8,  6, (9, ), -1)
\end{verbatim}

Note that while going forward we cannot discard records that will not ultimately be used
as we have no {\it a priori} criterion.
For example, records relating to chromosome $4$ are never used in sampling
coalescence from $8$ and $9$ but this is not known going forward.
Thus, whether or not we construct records in forward time along with the simulation
we will need to need to use backward-time analysis to combine the records to a
minimal set as {\tt msprime} requires (see {\it Combining Records} below).

\subsection*{Going backward}
Moving back in time, in the parent generation, a haplotype on the right coalesces
in chromosome $6$,
\begin{verbatim}
	A' = (x_8, L, 6, (8, 9), -1)
\end{verbatim}
The rest of the chromosome has yet to coalesce,
\begin{verbatim}
	B' = (0, x_8, 5, (8, ), -1)
	C' = (0, x_9, 7, (9, ), -1)
	D' = (x_9, x_8, 6, (9, ), -1)
\end{verbatim}

In the grandparent generation, the other parts coalesce
\begin{verbatim}
	F' = (0, x_5, 3, (5, 7), -2)
	G' = (x_9, x_8, 2, (5, 6), -2)
\end{verbatim}

\subsection*{Combining Records}

The singleton records in the parent generation (i.e., {\tt H, I, J} in forward
time or {\tt B', C' D'} in backward time) can be followed up to the grandparent generation.
Combined with the relevant coalescences in the grandparent generation (i.e.,
{\tt C, D, F} in forward time or {\tt F', G'} in backward time), these form complete records.
For example, assume recombination points in chromosome $5$ and $9$ coincide and let $a = x_5 =x_9$.
Then the complete records
\begin{verbatim}
	(0, a, 3, (8, 9), -2)
	(a, x_8, 2, (8, 9), -2)
\end{verbatim}
Then, together with the one complete coalescence in the parent ({\tt G} in
forward time or {\tt A'} in backward time)
\begin{verbatim}
	(x_8, L, 6, (8, 9), -1)
\end{verbatim}
these form a complete set of records.


\subsection*{Renumbering nodes and enumerating trees}
Once the complete set of records is formed, to meet {\tt msprime} requirements
for a dense tree in the records, we renumber in ascending order from the leaves
(the mapping from the chromosome numbers listed above is $8 \to 0; 9 \to 1; 6
\to 2; 3 \to 3; 2 \to 4$).

The complete set of records describes a dense tree sequence
\begin{verbatim}
	(x_8, L, 2, (0, 1), -1)
	(0, a, 3, (0, 1), -2)
	(a, x_8, 4, (0, 1), -2)
\end{verbatim}
and encodes the following sparse trees (moving left to right across the
chromosome and encoding trees as integer vectors with {\tt -1} signifying the
root)
\begin{verbatim}
	0, a: (3, 3, NA, -1, NA)
	a, x_8: (4, 4, NA, NA, -1)
	x_8, L: (2, 2, -1, NA, NA)
\end{verbatim}

\end{document}
