Wrote profile results to test_recomb_collector.py.lprof
Timer unit: 1e-06 s

Total time: 2.21355 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: add_individual at line 26

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    26                                               @profile
    27                                               def add_individual(self, name, time, population=msprime.NULL_POPULATION,
    28                                                                  is_sample=False):
    29                                                   '''Add a new individual.
    30                                                   We need to add individuals when they are *born*,
    31                                                   rather than the first time they reproduce, to ensure
    32                                                   that records are output in order by birth time of the parent.
    33                                                   '''
    34    402005       312421      0.8     14.1          if name not in self:
    35    402005       229132      0.6     10.4              self[name] = (msprime.Node(time=time, population=population,
    36    402005      1169454      2.9     52.8                                         name=name, is_sample=is_sample), [])
    37    402005       502542      1.3     22.7              self.num_nodes = max(self.num_nodes, 1+int(name))

Total time: 29.8855 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: add_record at line 39

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    39                                               @profile
    40                                               def add_record(self, left, right, parent, children):
    41                                                   '''
    42                                                   Add records corresponding to a reproduction event in which children (a
    43                                                   tuple of IDs) inherit from parent (a single ID) on the interval
    44                                                   [left,right).
    45                                                   '''
    46                                                   # unneeded but helpful for debugging
    47    559608       637110      1.1      2.1          if parent not in self.keys():
    48                                                       raise ValueError("Parent " + str(parent) +
    49                                                                        "'s birth time has not been recorded with " +
    50                                                                        ".add_individual().")
    51                                                   # time = self[parent][0]
    52    559608       314858      0.6      1.1          new_rec = msprime.Edgeset(
    53    559608       265560      0.5      0.9                  parent=parent,
    54    559608       250048      0.4      0.8                  children=children,
    55    559608       239496      0.4      0.8                  left=left,
    56    559608      1990254      3.6      6.7                  right=right)
    57    559608     26188192     46.8     87.6          merge_records(new_rec, self[parent][1])

Total time: 15.5276 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: merge_records at line 142

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   142                                           @profile
   143                                           def merge_records(new, existing):
   144                                               '''
   145                                               Incorporate a new record (l,r,x,c,t[x])
   146                                                 into a list of existing ones (a,b,x,C,t[x]) sorted on left endpoint.
   147                                               Keeping them in sorted order simplifies the procedure
   148                                                 (makes it so we don't have to split the new record).
   149                                               '''
   150    559608       481612      0.9      3.1      k = 0
   151    559608       339875      0.6      2.2      cur_left = new.left
   152                                               # print("MR: -----")
   153                                               # print("adding", new)
   154                                               # print("    to", existing)
   155   1115089       945952      0.8      6.1      while (k < len(existing)) and (cur_left < new.right):
   156    555481       490223      0.9      3.2          left = existing[k].left
   157    555481       349657      0.6      2.3          right = existing[k].right
   158    555481       345339      0.6      2.2          parent = existing[k].parent
   159    555481       365655      0.7      2.4          children = existing[k].children
   160                                                   # print("k:",k)
   161                                                   # print("existing:",existing[k])
   162                                                   # print("cur_left:",cur_left)
   163    555481       338301      0.6      2.2          if new.parent != parent:
   164                                                       raise ValueError("Trying to merge records with different parents.")
   165    555481       331886      0.6      2.1          if right <= cur_left:
   166                                                       # no overlap
   167                                                       # print("no overlap")
   168     64428        37979      0.6      0.2              k += 1
   169     64428        31858      0.5      0.2              continue
   170    491053       270569      0.6      1.7          if cur_left < left:
   171                                                       # print("dangling left")
   172     46793        33272      0.7      0.2              existing.insert(k, msprime.Edgeset(
   173     46793        24317      0.5      0.2                  left=cur_left,
   174     46793        54625      1.2      0.4                  right=min(new.right, left),
   175     46793        23937      0.5      0.2                  parent=parent,
   176     46793       142183      3.0      0.9                  children=new.children))
   177     46793        56301      1.2      0.4              cur_left = min(new.right, left)
   178     46793        29363      0.6      0.2              k += 1
   179     46793        23620      0.5      0.2              continue
   180    444260      1227743      2.8      7.9          combined_children = tuple(sorted(children+new.children))
   181    444260       316802      0.7      2.0          combined_rec = msprime.Edgeset(
   182    444260       237014      0.5      1.5              left=cur_left,
   183    444260      1003453      2.3      6.5              right=min(new.right, right),
   184    444260       261655      0.6      1.7              parent=new.parent,
   185    444260      1521928      3.4      9.8              children=combined_children)
   186    444260       303782      0.7      2.0          if cur_left == left:
   187                                                       # print("equal left")
   188    374504       265749      0.7      1.7              if new.right < right:
   189                                                           # print("overlap right")
   190     62926        39431      0.6      0.3                  mod_rec = msprime.Edgeset(
   191     62926        35946      0.6      0.2                          left=new.right,
   192     62926        34162      0.5      0.2                          right=right,
   193     62926        33894      0.5      0.2                          parent=parent,
   194     62926       552628      8.8      3.6                          children=children)
   195     62926        65417      1.0      0.4                  existing[k] = combined_rec
   196     62926        41385      0.7      0.3                  k += 1
   197     62926        63402      1.0      0.4                  existing.insert(k, mod_rec)
   198     62926        42739      0.7      0.3                  k += 1
   199                                                       else:
   200                                                           # print("dangling right")
   201    311578       287545      0.9      1.9                  existing[k] = combined_rec
   202    311578       216263      0.7      1.4                  k += 1
   203                                                   else:
   204                                                       # here we know that left < cur_left < right
   205                                                       # print("overlap left")
   206     69756        45277      0.6      0.3              mod_rec = msprime.Edgeset(
   207     69756        38909      0.6      0.3                      left=left,
   208     69756        37352      0.5      0.2                      right=cur_left,
   209     69756        36927      0.5      0.2                      parent=parent,
   210     69756       313090      4.5      2.0                      children=children)
   211     69756        69524      1.0      0.4              existing[k] = mod_rec
   212     69756        45909      0.7      0.3              k += 1
   213     69756        65553      0.9      0.4              existing.insert(k, combined_rec)
   214     69756        43987      0.6      0.3              k += 1
   215     69756        51920      0.7      0.3              if new.right < right:
   216                                                           # print("overlap right")
   217      6529         4810      0.7      0.0                  existing.insert(k, msprime.Edgeset(
   218      6529         3922      0.6      0.0                      left=new.right,
   219      6529         3695      0.6      0.0                      right=right,
   220      6529         3661      0.6      0.0                      parent=parent,
   221      6529        16014      2.5      0.1                      children=children))
   222      6529         4215      0.6      0.0                  k += 1
   223    444260       420557      0.9      2.7          cur_left = min(new.right, right)
   224                                               # add whatever's left at the end
   225    559608       406147      0.7      2.6      if cur_left < new.right:
   226    309136       230955      0.7      1.5          existing.insert(k, msprime.Edgeset(
   227    309136       178791      0.6      1.2              left=cur_left,
   228    309136       191835      0.6      1.2              right=new.right,
   229    309136       182679      0.6      1.2              parent=new.parent,
   230    309136      1575403      5.1     10.1              children=new.children))
   231                                               # print("getting")
   232                                               # for x in existing:
   233                                               #     print("   ", x)
   234    559608       289035      0.5      1.9      return None

Total time: 45.2746 s
File: tests/test_recomb_collector.py
Function: test_simupop at line 96

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    96                                           @profile
    97                                           def test_simupop(make_pop, generations, popsize):
    98         1            7      7.0      0.0      print("Popsize: ", popsize)
    99                                               # replications = 1
   100         1            1      1.0      0.0      nsamples = 2
   101         1            1      1.0      0.0      length = 10
   102         1            1      1.0      0.0      nloci = 5
   103         1            4      4.0      0.0      locus_position = list(range(0, length, int(length/nloci)))
   104         1            1      1.0      0.0      recomb_rate = 0.05
   105                                           
   106         1            0      0.0      0.0      rc = RecombCollector(
   107         1            0      0.0      0.0              nsamples=nsamples, generations=generations, N=popsize,
   108         1        26109  26109.0      0.1              ancestor_age=10, length=length, locus_position=locus_position)
   109                                           
   110         1           61     61.0      0.0      init_geno = [sim.InitGenotype(freq=[0.9, 0.1], loci=sim.ALL_AVAIL)]
   111                                           
   112         1           12     12.0      0.0      id_tagger = sim.IdTagger(begin=0)
   113         1            6      6.0      0.0      id_tagger.reset(startID=1)  # must reset - creating a new one doesn't
   114         1            1      1.0      0.0      pop = make_pop(popsize, nloci, locus_position, id_tagger, init_geno,
   115         1     45247223 45247223.0     99.9                     recomb_rate, rc, generations)
   116         1          707    707.0      0.0      locations = [pop.subPopIndPair(x)[0] for x in range(pop.popSize())]
   117         1          515    515.0      0.0      rc.add_diploid_samples(pop.indInfo("ind_id"), locations)

