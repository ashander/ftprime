Wrote profile results to test_recomb_collector.py.lprof
Timer unit: 1e-06 s

Total time: 2.28796 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: add_individual at line 26

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    26                                               @profile
    27                                               def add_individual(self, name, time, population=msprime.NULL_POPULATION,
    28                                                                  is_sample=False):
    29                                                   '''Add a new individual.
    30                                                   We need to add individuals when they are *born*,
    31                                                   rather than the first time they reproduce, to ensure
    32                                                   that records are output in order by birth time of the parent.
    33                                                   '''
    34    402005       320650      0.8     14.0          if name not in self:
    35    402005       238573      0.6     10.4              self[name] = (msprime.Node(time=time, population=population,
    36    402005      1231482      3.1     53.8                                         name=name, is_sample=is_sample), [])
    37    402005       497256      1.2     21.7              self.num_nodes = max(self.num_nodes, 1+int(name))

Total time: 29.878 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: add_record at line 39

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    39                                               @profile
    40                                               def add_record(self, left, right, parent, children):
    41                                                   '''
    42                                                   Add records corresponding to a reproduction event in which children (a
    43                                                   tuple of IDs) inherit from parent (a single ID) on the interval
    44                                                   [left,right).
    45                                                   '''
    46                                                   # unneeded but helpful for debugging
    47    559608       799704      1.4      2.7          if parent not in self.keys():
    48                                                       raise ValueError("Parent " + str(parent) +
    49                                                                        "'s birth time has not been recorded with " +
    50                                                                        ".add_individual().")
    51                                                   # time = self[parent][0]
    52    559608       339309      0.6      1.1          new_rec = msprime.Edgeset(
    53    559608       276814      0.5      0.9                  parent=parent,
    54    559608       256989      0.5      0.9                  children=children,
    55    559608       254082      0.5      0.9                  left=left,
    56    559608      1489470      2.7      5.0                  right=right)
    57    559608     26461636     47.3     88.6          merge_records(new_rec, self[parent][1])

Total time: 16.3576 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: merge_records at line 142

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   142                                           @profile
   143                                           def merge_records(new, existing):
   144                                               '''
   145                                               Incorporate a new record (l,r,x,c,t[x])
   146                                                 into a list of existing ones (a,b,x,C,t[x]) sorted on left endpoint.
   147                                               Keeping them in sorted order simplifies the procedure
   148                                                 (makes it so we don't have to split the new record).
   149                                               '''
   150    559608      1563370      2.8      9.6      k = 0
   151    559608       343556      0.6      2.1      cur_left = new.left
   152                                               # print("MR: -----")
   153                                               # print("adding", new)
   154                                               # print("    to", existing)
   155   1115266       963964      0.9      5.9      while (k < len(existing)) and (cur_left < new.right):
   156    555658       508057      0.9      3.1          left = existing[k].left
   157    555658       355931      0.6      2.2          right = existing[k].right
   158    555658       350275      0.6      2.1          parent = existing[k].parent
   159    555658       366891      0.7      2.2          children = existing[k].children
   160                                                   # print("k:",k)
   161                                                   # print("existing:",existing[k])
   162                                                   # print("cur_left:",cur_left)
   163    555658       336903      0.6      2.1          if new.parent != parent:
   164                                                       raise ValueError("Trying to merge records with different parents.")
   165    555658       330761      0.6      2.0          if right <= cur_left:
   166                                                       # no overlap
   167                                                       # print("no overlap")
   168     64560        38082      0.6      0.2              k += 1
   169     64560        32076      0.5      0.2              continue
   170    491098       271582      0.6      1.7          if cur_left < left:
   171                                                       # print("dangling left")
   172     46958        33681      0.7      0.2              existing.insert(k, msprime.Edgeset(
   173     46958        24061      0.5      0.1                  left=cur_left,
   174     46958        53415      1.1      0.3                  right=min(new.right, left),
   175     46958        24232      0.5      0.1                  parent=parent,
   176     46958       143949      3.1      0.9                  children=new.children))
   177     46958        51934      1.1      0.3              cur_left = min(new.right, left)
   178     46958        29963      0.6      0.2              k += 1
   179     46958        23954      0.5      0.1              continue
   180    444140      1513825      3.4      9.3          combined_children = tuple(sorted(children+new.children))
   181    444140       601062      1.4      3.7          combined_rec = msprime.Edgeset(
   182    444140       237600      0.5      1.5              left=cur_left,
   183    444140       894437      2.0      5.5              right=min(new.right, right),
   184    444140       262270      0.6      1.6              parent=new.parent,
   185    444140      1173999      2.6      7.2              children=combined_children)
   186    444140       290592      0.7      1.8          if cur_left == left:
   187                                                       # print("equal left")
   188    374591       267743      0.7      1.6              if new.right < right:
   189                                                           # print("overlap right")
   190     62946        39608      0.6      0.2                  mod_rec = msprime.Edgeset(
   191     62946        36558      0.6      0.2                          left=new.right,
   192     62946        36056      0.6      0.2                          right=right,
   193     62946        34178      0.5      0.2                          parent=parent,
   194     62946       191912      3.0      1.2                          children=children)
   195     62946        65663      1.0      0.4                  existing[k] = combined_rec
   196     62946        41032      0.7      0.3                  k += 1
   197     62946        61760      1.0      0.4                  existing.insert(k, mod_rec)
   198     62946        42943      0.7      0.3                  k += 1
   199                                                       else:
   200                                                           # print("dangling right")
   201    311645       291891      0.9      1.8                  existing[k] = combined_rec
   202    311645       216618      0.7      1.3                  k += 1
   203                                                   else:
   204                                                       # here we know that left < cur_left < right
   205                                                       # print("overlap left")
   206     69549        45708      0.7      0.3              mod_rec = msprime.Edgeset(
   207     69549        38658      0.6      0.2                      left=left,
   208     69549        37008      0.5      0.2                      right=cur_left,
   209     69549        37283      0.5      0.2                      parent=parent,
   210     69549       193916      2.8      1.2                      children=children)
   211     69549        69996      1.0      0.4              existing[k] = mod_rec
   212     69549        45173      0.6      0.3              k += 1
   213     69549        65443      0.9      0.4              existing.insert(k, combined_rec)
   214     69549        44130      0.6      0.3              k += 1
   215     69549        52116      0.7      0.3              if new.right < right:
   216                                                           # print("overlap right")
   217      6539         4796      0.7      0.0                  existing.insert(k, msprime.Edgeset(
   218      6539         3996      0.6      0.0                      left=new.right,
   219      6539         3774      0.6      0.0                      right=right,
   220      6539         3700      0.6      0.0                      parent=parent,
   221      6539        16880      2.6      0.1                      children=children))
   222      6539         4174      0.6      0.0                  k += 1
   223    444140       421187      0.9      2.6          cur_left = min(new.right, right)
   224                                               # add whatever's left at the end
   225    559608       412823      0.7      2.5      if cur_left < new.right:
   226    309093       239751      0.8      1.5          existing.insert(k, msprime.Edgeset(
   227    309093       178473      0.6      1.1              left=cur_left,
   228    309093       192582      0.6      1.2              right=new.right,
   229    309093       182228      0.6      1.1              parent=new.parent,
   230    309093      1630994      5.3     10.0              children=new.children))
   231                                               # print("getting")
   232                                               # for x in existing:
   233                                               #     print("   ", x)
   234    559608       286449      0.5      1.8      return None

Total time: 45.6963 s
File: tests/test_recomb_collector.py
Function: _make_pop at line 53

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    53                                               @profile
    54                                               def _make_pop(popsize, nloci, locus_position, id_tagger, init_geno,
    55                                                             recomb_rate, rc, generations):
    56         1            5      5.0      0.0          sim.setOptions(seed=111)
    57         1            1      1.0      0.0          recombinator = sim.Recombinator(intensity=recomb_rate,
    58         1            1      1.0      0.0                                          output=rc.collect_recombs,
    59         1           54     54.0      0.0                                          infoFields="ind_id")
    60         1            1      1.0      0.0          pop = sim.Population(
    61         1            1      1.0      0.0                  size=[popsize],
    62         1            0      0.0      0.0                  loci=[nloci],
    63         1            1      1.0      0.0                  lociPos=locus_position,
    64         1           72     72.0      0.0                  infoFields=['ind_id'])
    65         1            2      2.0      0.0          pop.evolve(
    66                                                       initOps=[
    67         1            6      6.0      0.0                  sim.InitSex(),
    68         1            1      1.0      0.0                  id_tagger
    69         1            1      1.0      0.0              ]+init_geno,
    70                                                       preOps=[
    71         1           13     13.0      0.0                  sim.PyOperator(lambda pop: rc.increment_time() or True),
    72                                                           # Must return true or false. True keeps whole population (?)
    73                                                       ],
    74         1          146    146.0      0.0              matingScheme=mating_scheme_factory(recombinator, popsize),
    75         1     45696018 45696018.0    100.0              gen=generations
    76                                                   )
    77         1            1      1.0      0.0          return pop

Total time: 45.7214 s
File: tests/test_recomb_collector.py
Function: test_simupop at line 94

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    94                                           @profile
    95                                           def test_simupop(make_pop, generations, popsize):
    96         1            7      7.0      0.0      print("Popsize: ", popsize)
    97                                               # replications = 1
    98         1            1      1.0      0.0      nsamples = 2
    99         1            1      1.0      0.0      length = 10
   100         1            1      1.0      0.0      nloci = 5
   101         1            5      5.0      0.0      locus_position = list(range(0, length, int(length/nloci)))
   102         1            1      1.0      0.0      recomb_rate = 0.05
   103                                           
   104         1            1      1.0      0.0      rc = RecombCollector(
   105         1            1      1.0      0.0              nsamples=nsamples, generations=generations, N=popsize,
   106         1        23683  23683.0      0.1              ancestor_age=10, length=length, locus_position=locus_position)
   107                                           
   108         1           59     59.0      0.0      init_geno = [sim.InitGenotype(freq=[0.9, 0.1], loci=sim.ALL_AVAIL)]
   109                                           
   110         1           12     12.0      0.0      id_tagger = sim.IdTagger(begin=0)
   111         1            5      5.0      0.0      id_tagger.reset(startID=1)  # must reset - creating a new one doesn't
   112         1            1      1.0      0.0      pop = make_pop(popsize, nloci, locus_position, id_tagger, init_geno,
   113         1     45696352 45696352.0     99.9                     recomb_rate, rc, generations)
   114         1          702    702.0      0.0      locations = [pop.subPopIndPair(x)[0] for x in range(pop.popSize())]
   115         1          581    581.0      0.0      rc.add_diploid_samples(pop.indInfo("ind_id"), locations)

