Wrote profile results to test_recomb_collector.py.lprof
Timer unit: 1e-06 s

Total time: 2.28065 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: add_individual at line 26

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    26                                               @profile
    27                                               def add_individual(self, name, time, population=msprime.NULL_POPULATION,
    28                                                                  is_sample=False):
    29                                                   '''Add a new individual.
    30                                                   We need to add individuals when they are *born*,
    31                                                   rather than the first time they reproduce, to ensure
    32                                                   that records are output in order by birth time of the parent.
    33                                                   '''
    34    402005       327178      0.8     14.3          if name not in self:
    35    402005       237900      0.6     10.4              self[name] = (msprime.Node(time=time, population=population,
    36    402005      1182893      2.9     51.9                                         name=name, is_sample=is_sample), [])
    37    402005       532681      1.3     23.4              self.num_nodes = max(self.num_nodes, 1+int(name))

Total time: 29.7806 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: add_record at line 39

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    39                                               @profile
    40                                               def add_record(self, left, right, parent, children):
    41                                                   '''
    42                                                   Add records corresponding to a reproduction event in which children (a
    43                                                   tuple of IDs) inherit from parent (a single ID) on the interval
    44                                                   [left,right).
    45                                                   '''
    46                                                   # unneeded but helpful for debugging
    47    559608      1316797      2.4      4.4          if parent not in self.keys():
    48                                                       raise ValueError("Parent " + str(parent) +
    49                                                                        "'s birth time has not been recorded with " +
    50                                                                        ".add_individual().")
    51                                                   # time = self[parent][0]
    52    559608       316729      0.6      1.1          new_rec = msprime.Edgeset(
    53    559608       268002      0.5      0.9                  parent=parent,
    54    559608       244506      0.4      0.8                  children=children,
    55    559608       241549      0.4      0.8                  left=left,
    56    559608      1547125      2.8      5.2                  right=right)
    57    559608     25845876     46.2     86.8          merge_records(new_rec, self[parent][1])

Total time: 15.6038 s
File: /home/jaime/lib/ftprime/ftprime/argrecorder.py
Function: merge_records at line 142

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   142                                           @profile
   143                                           def merge_records(new, existing):
   144                                               '''
   145                                               Incorporate a new record (l,r,x,c,t[x])
   146                                                 into a list of existing ones (a,b,x,C,t[x]) sorted on left endpoint.
   147                                               Keeping them in sorted order simplifies the procedure
   148                                                 (makes it so we don't have to split the new record).
   149                                               '''
   150    559608      1326820      2.4      8.5      k = 0
   151    559608       357924      0.6      2.3      cur_left = new.left
   152                                               # print("MR: -----")
   153                                               # print("adding", new)
   154                                               # print("    to", existing)
   155   1115136       963906      0.9      6.2      while (k < len(existing)) and (cur_left < new.right):
   156    555528       503313      0.9      3.2          left = existing[k].left
   157    555528       357472      0.6      2.3          right = existing[k].right
   158    555528       350369      0.6      2.2          parent = existing[k].parent
   159    555528       360336      0.6      2.3          children = existing[k].children
   160                                                   # print("k:",k)
   161                                                   # print("existing:",existing[k])
   162                                                   # print("cur_left:",cur_left)
   163    555528       336751      0.6      2.2          if new.parent != parent:
   164                                                       raise ValueError("Trying to merge records with different parents.")
   165    555528       334317      0.6      2.1          if right <= cur_left:
   166                                                       # no overlap
   167                                                       # print("no overlap")
   168     64443        37744      0.6      0.2              k += 1
   169     64443        31531      0.5      0.2              continue
   170    491085       272696      0.6      1.7          if cur_left < left:
   171                                                       # print("dangling left")
   172     46811        33206      0.7      0.2              existing.insert(k, msprime.Edgeset(
   173     46811        24385      0.5      0.2                  left=cur_left,
   174     46811        54986      1.2      0.4                  right=min(new.right, left),
   175     46811        24179      0.5      0.2                  parent=parent,
   176     46811       140550      3.0      0.9                  children=new.children))
   177     46811        56437      1.2      0.4              cur_left = min(new.right, left)
   178     46811        29029      0.6      0.2              k += 1
   179     46811        23164      0.5      0.1              continue
   180    444274       793270      1.8      5.1          combined_children = tuple(sorted(children+new.children))
   181    444274       452577      1.0      2.9          combined_rec = msprime.Edgeset(
   182    444274       240969      0.5      1.5              left=cur_left,
   183    444274       670205      1.5      4.3              right=min(new.right, right),
   184    444274       266848      0.6      1.7              parent=new.parent,
   185    444274      1324300      3.0      8.5              children=combined_children)
   186    444274       293177      0.7      1.9          if cur_left == left:
   187                                                       # print("equal left")
   188    374597       271651      0.7      1.7              if new.right < right:
   189                                                           # print("overlap right")
   190     62980        38856      0.6      0.2                  mod_rec = msprime.Edgeset(
   191     62980        37919      0.6      0.2                          left=new.right,
   192     62980        34621      0.5      0.2                          right=right,
   193     62980        34063      0.5      0.2                          parent=parent,
   194     62980       174581      2.8      1.1                          children=children)
   195     62980        65782      1.0      0.4                  existing[k] = combined_rec
   196     62980        41135      0.7      0.3                  k += 1
   197     62980        62275      1.0      0.4                  existing.insert(k, mod_rec)
   198     62980        42888      0.7      0.3                  k += 1
   199                                                       else:
   200                                                           # print("dangling right")
   201    311617       293482      0.9      1.9                  existing[k] = combined_rec
   202    311617       217959      0.7      1.4                  k += 1
   203                                                   else:
   204                                                       # here we know that left < cur_left < right
   205                                                       # print("overlap left")
   206     69677        43915      0.6      0.3              mod_rec = msprime.Edgeset(
   207     69677        39292      0.6      0.3                      left=left,
   208     69677        37677      0.5      0.2                      right=cur_left,
   209     69677        38197      0.5      0.2                      parent=parent,
   210     69677       759606     10.9      4.9                      children=children)
   211     69677        69563      1.0      0.4              existing[k] = mod_rec
   212     69677        45212      0.6      0.3              k += 1
   213     69677        66250      1.0      0.4              existing.insert(k, combined_rec)
   214     69677        43517      0.6      0.3              k += 1
   215     69677        53571      0.8      0.3              if new.right < right:
   216                                                           # print("overlap right")
   217      6546         4822      0.7      0.0                  existing.insert(k, msprime.Edgeset(
   218      6546         4187      0.6      0.0                      left=new.right,
   219      6546         3787      0.6      0.0                      right=right,
   220      6546         3756      0.6      0.0                      parent=parent,
   221      6546        16401      2.5      0.1                      children=children))
   222      6546         4353      0.7      0.0                  k += 1
   223    444274       418285      0.9      2.7          cur_left = min(new.right, right)
   224                                               # add whatever's left at the end
   225    559608       414958      0.7      2.7      if cur_left < new.right:
   226    309105       234729      0.8      1.5          existing.insert(k, msprime.Edgeset(
   227    309105       180711      0.6      1.2              left=cur_left,
   228    309105       202110      0.7      1.3              right=new.right,
   229    309105       191629      0.6      1.2              parent=new.parent,
   230    309105      1463548      4.7      9.4              children=new.children))
   231                                               # print("getting")
   232                                               # for x in existing:
   233                                               #     print("   ", x)
   234    559608       288005      0.5      1.8      return None

Total time: 5e-06 s
File: tests/test_recomb_collector.py
Function: make_pop at line 48

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    48                                           @profile
    49                                           def make_pop(request):
    50                                               # request.param stores a lambda function to make mating scheme
    51                                               # each test that uses this fixture will be run for both entries in 'params'
    52         1            2      2.0     40.0      mating_scheme_factory = request.param
    53                                           
    54         1            2      2.0     40.0      def _make_pop(popsize, nloci, locus_position, id_tagger, init_geno,
    55                                                             recomb_rate, rc, generations):
    56                                                   sim.setOptions(seed=111)
    57                                                   recombinator = sim.Recombinator(intensity=recomb_rate,
    58                                                                                   output=rc.collect_recombs,
    59                                                                                   infoFields="ind_id")
    60                                                   pop = sim.Population(
    61                                                           size=[popsize],
    62                                                           loci=[nloci],
    63                                                           lociPos=locus_position,
    64                                                           infoFields=['ind_id'])
    65                                                   pop.evolve(
    66                                                       initOps=[
    67                                                           sim.InitSex(),
    68                                                           id_tagger
    69                                                       ]+init_geno,
    70                                                       preOps=[
    71                                                           sim.PyOperator(lambda pop: rc.increment_time() or True),
    72                                                           # Must return true or false. True keeps whole population (?)
    73                                                       ],
    74                                                       matingScheme=mating_scheme_factory(recombinator, popsize),
    75                                                       postOps=[
    76                                                           sim.PyEval(r"'Gen: %2d\n' % (gen, )", step=1)
    77                                                       ],
    78                                                       gen=generations
    79                                                   )
    80                                                   return pop
    81         1            1      1.0     20.0      return _make_pop

Total time: 45.4613 s
File: tests/test_recomb_collector.py
Function: test_simupop at line 97

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    97                                           @profile
    98                                           def test_simupop(make_pop, generations, popsize):
    99         1            6      6.0      0.0      print("Popsize: ", popsize)
   100                                               # replications = 1
   101         1            1      1.0      0.0      nsamples = 2
   102         1            1      1.0      0.0      length = 10
   103         1            1      1.0      0.0      nloci = 5
   104         1            5      5.0      0.0      locus_position = list(range(0, length, int(length/nloci)))
   105         1            1      1.0      0.0      recomb_rate = 0.05
   106                                           
   107         1            1      1.0      0.0      rc = RecombCollector(
   108         1            1      1.0      0.0              nsamples=nsamples, generations=generations, N=popsize,
   109         1        24590  24590.0      0.1              ancestor_age=10, length=length, locus_position=locus_position)
   110                                           
   111         1           69     69.0      0.0      init_geno = [sim.InitGenotype(freq=[0.9, 0.1], loci=sim.ALL_AVAIL)]
   112                                           
   113         1           13     13.0      0.0      id_tagger = sim.IdTagger(begin=0)
   114         1            7      7.0      0.0      id_tagger.reset(startID=1)  # must reset - creating a new one doesn't
   115         1            2      2.0      0.0      pop = make_pop(popsize, nloci, locus_position, id_tagger, init_geno,
   116         1     45435320 45435320.0     99.9                     recomb_rate, rc, generations)
   117         1          702    702.0      0.0      locations = [pop.subPopIndPair(x)[0] for x in range(pop.popSize())]
   118         1          541    541.0      0.0      rc.add_diploid_samples(pop.indInfo("ind_id"), locations)

