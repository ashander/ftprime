<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="sparse-trees">Sparse trees</h1>
<p>A sparse tree is a sequence <span class="math inline"><em>π</em></span> of integers, with <span class="math inline"><em>π</em><sub><em>k</em></sub></span> denoting the parent of node <span class="math inline"><em>k</em></span>, and <span class="math inline">0</span> denoting no parent (as for example the root).</p>
<h1 id="building-a-sparse-tree-from-coalescent-records">Building a sparse tree from coalescent records</h1>
<p>Since coalescent records record parent <span class="math inline"><em>u</em></span> and children <span class="math inline"><em>c</em></span>, to build a tree out of a set of records one only needs to initialize the entries of <span class="math inline"><em>π</em></span> all to 0, and then to set the <span class="math inline"><em>c</em><sub><em>i</em></sub></span>th entries of <span class="math inline"><em>π</em></span> all equal to <span class="math inline"><em>u</em></span> for each <span class="math inline"><em>i</em></span>.</p>
<h1 id="generating-trees-the-tree-iterator">Generating trees (the tree iterator)</h1>
<p>Suppose we have the tree at <span class="math inline"><em>x</em></span> and the next record to the right begins at <span class="math inline">ℓ &gt; <em>x</em></span>. The algorithm moves from this tree to the next (at <span class="math inline">ℓ</span>) by first removing all records that end between <span class="math inline"><em>x</em></span> and <span class="math inline">ℓ</span> (by setting the parents of each of the children in each record to zero) and then adding all new records beginning at <span class="math inline">ℓ</span>.</p>
<div class="figure">
<img src="algorithm_t.png" alt="Algorithm T" />
<p class="caption">Algorithm T</p>
</div>
<p>Note that this assumes that all relevant entries get zeroed out when 'removing' records.</p>
<h2 id="questions">Questions:</h2>
<ol style="list-style-type: decimal">
<li><p>Can we have partially observed tips that are not samples?</p>
<ul>
<li><strong>Yes:</strong> if the largest ID is an internal node (or we change how memory is allocated)</li>
</ul></li>
<li><p>Can we have the same internal node be the parent of more than on coalescent record at different times?</p></li>
</ol>
<h2 id="python-version-from-jerome">Python version from Jerome</h2>
<pre class="{python}"><code>
def trees(records):
    M = len(records)
    I = sorted(range(M), key=lambda j: (records[j].left, records[j].time))
    O = sorted(range(M), key=lambda j: (records[j].right, -records[j].time))
    pi = [-1 for j in range(max(r.node for r in records) + 1)]
    chi = [[] for j in range(max(r.node for r in records) + 1)]
    j = 0
    k = 0
    while j &lt; M:
        x = records[I[j]].left
        while records[O[k]].right == x:
            h = O[k]
            print(&quot;\tout:&quot;, records[h])
            chi[records[h].node] = []
            for q in records[h].children:
                pi[q] = -1
            k += 1
        while j &lt; M and records[I[j]].left == x:
            h = I[j]
            print(&quot;\tin:&quot;, records[h])
            chi[records[h].node] = records[h].children
            for q in records[h].children:
                pi[q] = records[h].node
            j += 1
        yield pi, chi
</code></pre>
<h1 id="clock-time-or-meioses">Clock time or meioses</h1>
<p>Suppose that:</p>
<ol style="list-style-type: decimal">
<li>We start with individual <span class="math inline"><em>a</em></span> at <span class="math inline"><em>t</em> = 0</span>.</li>
<li><span class="math inline"><em>a</em></span> gives birth to <span class="math inline"><em>b</em></span> at <span class="math inline"><em>t</em> = 1</span>.</li>
<li><span class="math inline"><em>b</em></span> gives birth to <span class="math inline"><em>c</em></span> at <span class="math inline"><em>t</em> = 2</span>.</li>
<li><span class="math inline"><em>a</em></span> gives birth to <span class="math inline"><em>d</em></span> and <span class="math inline"><em>e</em></span> at <span class="math inline"><em>t</em> = 3</span>.</li>
<li><span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> die and we sample <span class="math inline"><em>c</em></span>, <span class="math inline"><em>d</em></span>, and <span class="math inline"><em>e</em></span> at <span class="math inline"><em>t</em> = 4</span>.</li>
</ol>
<p>What should the tree be? If we count in <strong>meioses</strong>, it should be</p>
<pre><code>                                        
2            a _                        
            / \ \                       
1          b   d e                      
          /                             
0        c                              </code></pre>
<p>Here, nodes = individuals.</p>
<p>On the other hand, if we count in <strong>clock time</strong>, then it should be</p>
<pre><code>                                        
4       a                               
        |\                              
3       a b                             
        | |\                            
2       a b c                           
       /|\ \ \                          
1     a d e b c                         
        | |   |                         
0       d e   c                         </code></pre>
<p>Here, nodes = (individuals at a particular point in time)</p>
<h1 id="forwards-time-algorithms">Forwards-time algorithms</h1>
<p>Requirements:</p>
<ol style="list-style-type: decimal">
<li>Coalescence records have at least two offspring.</li>
<li>Coalescence records are output in time-order.</li>
<li>We need to be able to re-label so samples have the first <span class="math inline"><em>n</em></span> labels at the end.</li>
</ol>
<h2 id="without-recombination">Without recombination</h2>
<p>This algorithm will be in <strong>clock time</strong>.</p>
<p>Now: the idea is that each branch of the tree gets a label; so we record coalescence records then a branch splits. As we move forwards in time, we keep track of:</p>
<ul>
<li><code>L</code> : a vector of unique labels, one for each individual currently alive</li>
</ul>
<p>and we write out coalescent records, which are:</p>
<ul>
<li><code>[parent, offspring, time]</code> : parent and offspring are labels of branch tips; the <code>time</code> is the time of <em>birth of the offspring</em>, so we measure time in <em>clock time</em>.</li>
</ul>
<h3 id="example">Example</h3>
<p>Here's the example above, extended slightly:</p>
<ol style="list-style-type: decimal">
<li>We start with individual <span class="math inline"><em>a</em></span> at <span class="math inline"><em>t</em> = 0</span>.</li>
<li><span class="math inline"><em>a</em></span> gives birth to <span class="math inline"><em>b</em></span> at <span class="math inline"><em>t</em> = 1</span>.</li>
<li><span class="math inline"><em>b</em></span> gives birth to <span class="math inline"><em>c</em></span> at <span class="math inline"><em>t</em> = 2</span>.</li>
<li><span class="math inline"><em>a</em></span> gives birth to <span class="math inline"><em>d</em></span> and <span class="math inline"><em>e</em></span> at <span class="math inline"><em>t</em> = 3</span>.</li>
<li><span class="math inline"><em>b</em></span> gives birth to <span class="math inline"><em>f</em></span> and <span class="math inline"><em>a</em></span> and <span class="math inline"><em>b</em></span> die at <span class="math inline"><em>t</em> = 4</span></li>
<li>We sample <span class="math inline"><em>c</em></span>, <span class="math inline"><em>d</em></span>, <span class="math inline"><em>e</em></span>, and <span class="math inline"><em>f</em></span>.</li>
</ol>
<p>With lineage labels on the right, and time now moving forwards:</p>
<pre><code>------------
time   tree        |   lineages      | current state |  records output

0       a          |       0         |  a:0          |              

------------

0       a          |       0         |               |  [ 0, (1,2), 0 ]               
        |\         |       |\        |  a:1          |                 
1       a b        |       1 2       |  b:2          |  

------------

0       a          |       0         |               |  
        |\         |       |\        |               |                 
1       a b        |       1 2       |  a:1          |  [ 2, (3,4), 1 ]               
        | |\       |       | |\      |  b:3          |                 
2       a b c      |       1 3 4     |  c:4          |  

------------
                                     |               |   
0       a          |       0         |               |  
        |\         |       |\        |               |                 
1       a b        |       1 2       |   a:5         |  
        | |\       |       | |\      |   b:3         |                 
2       a b c      |       1 3 4     |   c:4         |  [ 1, (5,6,7), 2 ]               
       /|\ \ \     |      /|\ \ \    |   d:6         |                 
3     a d e b c    |     5 6 7 3 4   |   e:7         |                 

------------
                                     |               |   
0       a          |       0         |               |  
        |\         |       |\        |               |                 
1       a b        |       1 2       |               |  
        | |\       |       | |\      |               |                 
2       a b c      |       1 3 4     |               |  
       /|\ \ \     |      /|\ \ \    |    c:4        |                 
3     a d e b c    |     5 6 7 3 4   |    d:6        |                 
      | | | |\ \   |       | |  \ \  |    e:7        |                 
4     * d e * f c  |       6 7   3 4 |    f:3        |  
</code></pre>
<p>Here we noticed that b died and was replaced by f, so kept just one lineage; otherwise we'd have:</p>
<pre><code>0       a          |       0         |               |  
        |\         |       |\        |               |                 
1       a b        |       1 2       |               |  
        | |\       |       | |\      |               |                 
2       a b c      |       1 3 4     |    c:4        |  
       /|\ \ \     |      /|\ \ \    |    d:6        |                 
3     a d e b c    |     5 6 7 3 4   |    e:7        |                 
      | | | |\ \   |       | | |\ \  |    f:9        |   [ 3, (8,9), 4 ]              
4     * d e * f c  |       6 7 8 9 4 |               |  
</code></pre>
<p>... where we only really have to output the coalescence record so as to remember that lineage 9 is a continuation of lineage 3. (But, either works.)</p>
<h3 id="algorithm-no-recombination">Algorithm, no recombination</h3>
<p>At each time step, some individuals die and some give birth. Let <span class="math inline"><em>L</em></span> denote the current vector of labels, one for each extant individual.</p>
<ol start="0" style="list-style-type: decimal">
<li>Begin with <span class="math inline"><em>L</em></span> a vector of unique labels.</li>
<li><p>For each birth and/or death at time <span class="math inline"><em>t</em></span>, consider the parent:</p>
<ol style="list-style-type: lower-alpha">
<li>If they die with no offspring, remove them.</li>
<li>If they die and leave one offspring, let their offspring inherit their label.</li>
<li>Otherwise, assign a new label to each offspring, and to <em>themselves</em>, if they survive. Let the label of the parent be <span class="math inline">ℓ<sub>0</sub></span> and these new labels be <span class="math inline">ℓ<sub>1</sub>, …, ℓ<sub><em>k</em></sub></span>, and output the coalescence record [ ( _0, (_1, , _k), t ) . ]</li>
</ol></li>
</ol>
<p>Check: every time a new label is assigned, it should appear in a coalescence record (so we know who it's parent is).</p>
<h2 id="jeromes-outline-of-forward-time-alg">Jerome's outline of forward-time alg</h2>
<!-- edited from his email per correction -->
<p>I think you're on the right track here, but I'm a bit confused as to why you're recording 'coalescences' where there is a single child. In my mind, the simplest way to think about this is to just imagine running the coalescent algorithm in reverse, using the same data structures. Suppose we were doing this for a single locus, and we started with ancestral individuals <code>[0, 1, 2, 3, 4, 5]</code>. Now, we generate some children randomly from this, and we get</p>
<p><code>[3, 2, 1, 3, 3, 0]</code></p>
<p>Since multiple children have chosen the same parent, we must have a coalescence. Replace the coalesced node with new IDs, giving</p>
<p><code>[6, 2, 1, 7, 8, 0]</code></p>
<p>and record the coalescence (6, 7, 8) -&gt; 3. Repeating, we get the next generation</p>
<p><code>[1, 1, 7, 8, 0, 0]</code></p>
<p>Because we have two distinct parents here, we have two coalescences:</p>
<p><code>[9, 10, 7, 8, 11, 12]</code></p>
<p>with records <code>(9, 10) -&gt; 1</code> and <code>(11, 12) -&gt; 0</code>.</p>
<p>The key thing here is that we only record <em>coalescences</em>, where actual changes to the topology of the trees occur. If only one child in the next generation inherits from a particular individual, then its node ID is passed on unchanged. When coalescences occur, we allocate new nodes for the children, so that they each become nodes in the genealogy.</p>
<p>A nice property of this representation is that it's easy to tell when we've simulated far enough forward in time to be sure that there is an MRCA: if you started with <code>n</code> individuals, and any <code>ID &lt; n</code> remains in the population, then you need to continue (thinking about this again, it may not be a sufficient condition though).</p>
<p>Once you get to the end, you should be able to rename your present day population as <code>0</code> to <code>n - 1</code>, update any affected records, and then use the tree sequence directly. Calling subset on this should then trim out all the stuff that you don't want. (Warning though: there is still a bug in subset when dealing with weird corner cases. If you hit a 'Bad records' when running subset it's because of this bug. Let me know if you do.)</p>
<p>This is nice and easy for a single locus, and it's a lot more tricky for multiple loci, of course. However, I think the same strategy as used in <code>msprime</code> will work, where each individual is a linked list of ancestral segments. The algorithms listed in the paper for manipulating these linked lists should also work here, as we're doing essentially the same thing. I think this will probably end up being equivalent to the approach that you're outlining, but it may be a bit simpler.</p>
<p>I would try to get things working for a single locus model first though, and see if the basic logic holds.</p>
<h2 id="with-recombination">With recombination</h2>
<p>We need only make sure we record from where each individual has inherited her genome. However, coalescence records focus on the &quot;other end&quot; of the relationship, siblingship.</p>
<p>Here's a minimal example: with <code>(i,j,x)-&gt;k</code> denoting that individual <code>k</code> inherits from <code>i</code> on <code>[0,x)</code> and from <code>j</code> on <code>[x,1)</code>:</p>
<ol style="list-style-type: decimal">
<li>Begin with an individual <code>a</code> (and another anonymous one) at <code>t=0</code>.</li>
<li><code>(a,?,1.0)-&gt;b</code> at <code>t=1</code></li>
<li><code>(a,b,0.5)-&gt;c</code> at <code>t=2</code></li>
<li><code>(a,c,0.2)-&gt;d</code> and <code>(c,b,0.6)-&gt;e</code> at <code>t=3</code>.</li>
<li><code>a</code> and <code>b</code> die, we sample <code>c,d,e</code> at <code>t=4</code>.</li>
</ol>
<h3 id="algorithm-no.-1">Algorithm No. 1</h3>
<p>As a first pass, we'll &quot;deal with death last&quot; at each time point, so that everyone has their parent as a &quot;sibling&quot;. Coalescent records are</p>
<pre><code>(left, right, node, (children), time)</code></pre>
<p>The current state is a list of labels, with each label corresponding to a currently alive individual.</p>
<pre><code>t  |   trees       |             lineages                                    |    state           |   records output                                              
                   |                                                                                             
0  |        a      |                         1                               |    1:a             |                        

# (a,?,1.0)-&gt;b , t=1
1  |        a      |                         1                               |                    |                        
   |       / \     |                        / \                              |    2:a             |   ( 0.0, 1.0, 1, (2,3), 1 )    
   |      a   b    |                       2   3                             |    3:b             |                        

# (a,b,0.5)-&gt;c , t=2
 2 |        a      |             1                           1               |                    |                        
   |       / \     |            / \                         / \              |                    |                        
   |      a   b    |           2   3                       2   3             |    4:a             |   ( 0.0, 0.5, 2, (4,6), 2 )
   |     / \ / \   |          / \   \                     /   / \            |    5:b             |   ( 0.5, 1.0, 3, (5,6), 2 )
   |    a   c   b  |         4   6   5                   4   6   5           |    6:c             |                         
   |               |                                                         |                    |                         
   |               |         [0.0,0.5)                    [0.5,1.0)          |                    |                         
                                                                    
# (a,c,0.2)-&gt;d , t=3                                                
3  |       a       |       1             1                    1              |                    |                         
   |      / \      |      / \           / \                  / \             |                    |                         
   |     a   b     |     2   3         2   3                2   3            |                    |   ( 0.0, 0.2, 4, (7,8), 3 )
   |    / \ / \    |    / \   \       / \   \              /   / \           |    5:b             |                         
   |   a   c   b   |   4   6   5     4   6   5            4   6   5          |                    |   ( 0.2, 1.0, 6, (8,9), 3 )    ** see below
   |  / \ /        |  / \           /   /|               /   /|              |    7:a             |                        
   | a   d         | 7   8         7   8 9              7   8 9              |    8:d             |                        
   |               |                                                         |    9:c             |                        
   |               |                                                         |                    |                        
   |               |  [0.0,0.2)      [0.2,0.5)             [0.5,1.0)         |                    |                        

# (c,b,0.6)-&gt;e , still t=3
3  |       a       |       1             1           1              1        |                    |                        
   |      / \      |      / \           / \         / \            / \       |                    |                        
   |     a   b     |     2   3         2   3       2   3          2   3      |                    |                        
   |    / \ / \    |    / \   \       / \   \     /   / \        /   / \     |                    |   ( 0.0, 0.2, 6, (9,10), 3 )
   |   a   c   b   |   4   6   5     4   6   5   4   6   5      4   6   5    |    7:a             |   ( 0.2, 0.6, 6, (8,9,10), 3 )   ** split
   |  / \ / \ / \  |  /|   |\   \    |  /|\   \  |  /|\   \    /   /|   |\   |    8:d             |   ( 0.6, 1.0, 6, (8,9), 3 )      ** split
   | a   d   e   b | 7 8   9 10 11   7 8 9 10 11 7 8 9 10 11  7   8 9  10 11 |    9:c             |                        
   |               |                                                         |   10:e             |                                   
   |               |  [0.0,0.2)      [0.2,0.5)    [0.5,0.6)      [0.6,1.0)   |   11:b             |   ( 0.6, 1.0, 5, (10,11), 3 )
                                                                           
# a,b die; sample c,d,e at t=4
3  |       a       |       1             1           1              1        |                    |                        
   |      / \      |      / \           / \         / \            / \       |                    |  
   |     a   b     |     2   3         2   3       2   3          2   3      |                    |  
   |    / \ / \    |    / \   \       / \   \     /   / \        /   / \     |                    |  
   |   a   c   b   |   4   6   5     4   6   5   4   6   5      4   6   5    |                    |  
   |  / \ /|\ / \  |  /|   |\   \    |  /|\   \  |  /|\   \    /   /|   |\   |    8:d             |  
   | a   d | e   b | 7 8   9 10 11   7 8 9 10 11 7 8 9 10 11  7   8 9  10 11 |                    |  
   |    /  |  \    |   |   |  \       /  |  \     /  |  \        /  |   |    |    9:c             |  
   |   d   c   e   |   8   9   10    8   9   10  8   9   10     8   9  10    |   10:e             |  
   |               |                                                         |                    |  
   |               |  [0.0,0.2)      [0.2,0.5)    [0.5,0.6)      [0.6,1.0)   |                    |  
   |               |                                                         |                    |  
</code></pre>
<p>What'd we do there? Every time there's a new individual, they get a lineage all to themselves (their whole genome). When anyone has offspring we create new lineages for the parents as well; these new lineages serve as siblings to their offspring in the new coalescent records. Sometimes in building coalescent records for events happening in the same generation, we modified one already in the pipeline.</p>
<p>Here's the order we add and remove records to create the trees in Algorithm T:</p>
<pre><code>  Adding                           |   Removing
  ------                           |   --------
1  ( 0.0, 1.0, 1, (2,3),    1 )    |
1  ( 0.0, 0.5, 2, (4,6),    2 )    |
1  ( 0.0, 0.2, 4, (7,8),    3 )    |
1  ( 0.0, 0.2, 6, (9,10),   3 )    |
                                   | 2  ( 0.0, 0.2, 4, (7,8),   3 )
                                   | 2  ( 0.0, 0.2, 6, (9,10),  3 )
2  ( 0.2, 0.6, 6, (8,9,10), 3 )    |
                                   | 3  ( 0.0, 0.5, 2, (4,6),   2 )
3  ( 0.5, 1.0, 3, (5,6),    2 )    |
                                   | 4  ( 0.2, 0.6, 6, (8,9,10),3 )
4  ( 0.6, 1.0, 6, (8,9),    3 )    |
4  ( 0.6, 1.0, 5, (10,11),  3 )    |
                                   | *  ( 0.6, 1.0, 6, (8,9),   3 )
                                   | *  ( 0.6, 1.0, 5, (10,11), 3 )
                                   | *  ( 0.5, 1.0, 3, (5,6),   2 )
                                   | *  ( 0.0, 1.0, 1, (2,3),   1 )    </code></pre>
<p><strong>Algorithm:</strong></p>
<p>Let <span class="math inline"><em>L</em></span> be the dictionary of labels (initiallized to a unique set); and let <span class="math inline"><em>u</em></span> be a list of flags denoting whether we've processed a reproduction for the individual this generation. At time point <span class="math inline"><em>t</em></span>:</p>
<ol start="0" style="list-style-type: decimal">
<li>Set every element of <span class="math inline"><em>u</em></span> to False.</li>
<li><p>For each birth, with parents <span class="math inline"><em>i</em></span>, <span class="math inline"><em>j</em></span> and offspring <span class="math inline"><em>k</em></span>:</p>
<ol style="list-style-type: lower-alpha">
<li><p>If <span class="math inline"><em>u</em>(<em>i</em>)</span> is False, assign a new label to <span class="math inline"><em>i</em></span>, and set <span class="math inline"><em>u</em>(<em>i</em>)</span> to True, and likewise for <span class="math inline"><em>j</em></span>. Let <span class="math inline"><em>L</em>′(<em>i</em>)</span> be the previous label for <span class="math inline"><em>i</em></span> and <span class="math inline"><em>L</em>(<em>i</em>)</span> the new label for <span class="math inline"><em>i</em></span> (possibly already assigned), and likewise for <span class="math inline"><em>j</em></span>; and let <span class="math inline"><em>L</em>(<em>k</em>)</span> be the label of the offspring.</p></li>
<li><p>Let <span class="math inline"><em>x</em><sub>0</sub> = 0 ≤ <em>x</em><sub>1</sub>, <em>x</em><sub>2</sub>, …, <em>x</em><sub><em>n</em></sub> ≤ <em>x</em><sub><em>n</em> = 1</sub> = 1</span> be the recombination breakpoints, with the offspring inheriting from <span class="math inline"><em>i</em></span> on <span class="math inline">[<em>x</em><sub>2</sub>ℓ,<em>x</em><sub>2ℓ+1</sub>)</span> and from <span class="math inline"><em>j</em></span> on <span class="math inline">[<em>x</em><sub>2</sub>ℓ+1, <em>x</em><sub>2ℓ+2</sub>)</span>; and output coalescence records <span class="math inline">(<em>x</em><sub>2</sub>ℓ,<em>x</em><sub>2ℓ+1</sub>, <em>L</em>′(<em>i</em>),(<em>L</em>(<em>i</em>),<em>L</em>(<em>k</em>)), <em>t</em>)</span> and <span class="math inline">(<em>x</em><sub>2</sub>ℓ+1, <em>x</em><sub>2ℓ+2</sub>, <em>L</em>′(<em>j</em>),(<em>L</em>(<em>j</em>),<em>L</em>(<em>k</em>)), <em>t</em>)</span> for each <span class="math inline">ℓ</span>.</p></li>
<li><p>Remove dead individuals.</p></li>
<li><p>Merge-and-split coalescence records that share a parent.</p></li>
</ol></li>
</ol>
<h3 id="algorithm-no.-2-probably-ignore-this">Algorithm No. 2 (probably ignore this!)</h3>
<p>The first algorithm has an inefficiency in that it records coalescent events for EVERY new offspring. Here is an algorithm that initially keeps track of <em>more</em>, but may be more amenable to subsequent pruning of redundant information.</p>
<p>The current state is a list of labels, with each label corresponding to a segment of a currently alive individual.</p>
<pre><code>t  |   trees       |             lineages                                    |    state           |   records output                                              
                   |                                                                                             
0  |        a      |                         1                               |    1:a,[0,1)       |                        

# (a,?,1.0)-&gt;b , t=1
1  |        a      |                         1                               |                    |                        
   |       / \     |                        / \                              |    2:a,[0,1)       |   ( 0.0, 1.0, 1, (2,3), 1 )    
   |      a   b    |                       2   3                             |    3:b,[0,1)       |                        

# (a,b,0.5)-&gt;c , t=2
 2 |        a      |             1                           1               |    2:a,[0.5,1.0) * |                        
   |       / \     |            / \                         / \              |    3:b,[0.0,0.5) * |                        
   |      a   b    |           2   3                       2   3             |    4:a,[0.0,0.5)   |   ( 0.0, 0.5, 2, (4,6), 2 )
   |     / \ / \   |          / \   \                     /   / \            |    5:b,[0.5,1.0)   |   ( 0.5, 1.0, 3, (5,6), 2 )
   |    a   c   b  |         4   6   3                   2   6   5           |    6:c,[0.0,1.0)   |                         
   |               |                                                         |                    |                         
   |               |         [0.0,0.5)                    [0.5,1.0)          |                    |                         
                                                                    
# (a,c,0.2)-&gt;d , t=3                                                
3  |       a       |       1             1                    1              |    2:a,[0.5,1.0)   |                         
   |      / \      |      / \           / \                  / \             |    3:b,[0.0,0.5)   |                         
   |     a   b     |     2   3         2   3                2   3            |    4:a,[0.2,0.5) * |   ( 0.0, 0.2, 4, (7,8), 3 )
   |    / \ / \    |    / \   \       / \   \              /   / \           |    5:b,[0.5,1.0)   |                         
   |   a   c   b   |   4   6   3     4   6   3            2   6   5          |    6:c,[0.0,0.2) * |   ( 0.2, 1.0, 6, (8,9), 3 )    ** see below
   |  / \ /        |  / \           /   / \                  / \             |    7:a,[0.0,0.2)   |                        
   | a   d         | 7   8         4   8   9                8   9            |    8:d,[0.0,1.0)   |                        
   |               |                                                         |    9:c,[0.2,1.0)   |                        
   |               |                                                         |                    |                        
   |               |  [0.0,0.2)      [0.2,0.5)             [0.5,1.0)         |                    |                        

# (c,b,0.6)-&gt;e , still t=3
3  |       a       |       1             1           1              1        |    2:a,[0.5,1.0)   |                        
   |      / \      |      / \           / \         / \            / \       |    3:b,[0.0,0.5)   |                        
   |     a   b     |     2   3         2   3       2   3          2   3      |    4:a,[0.2,0.5)   |                        
   |    / \ / \    |    / \   \       / \   \     /   / \        /   / \     |    5:b,[0.5,0.6) * |   ( 0.0, 0.2, 6, (10,11), 3 )
   |   a   c   b   |   4   6   3     4   6   3   2   6   5      2   6   5    |    7:a,[0.0,0.2)   |   ( 0.2, 0.6, 6, (8,9,11), 3 )   ** split
   |  / \ / \ / \  |  /|   |\       /   /|\         /|\            /|  / \   |    8:d,[0.0,1.0)   |   ( 0.6, 1.0, 6, (8,9), 3 )      ** split
   | a   d   e   b | 7 8  10 11    4   8 9 11      8 9 11         8 9 11 12  |    9:c,[0.2,1.0)   |                        
   |               |                                                         |   10:c,[0.0,0.2)   |                                   
   |               |  [0.0,0.2)      [0.2,0.5)    [0.5,0.6)      [0.6,1.0)   |   11:e,[0.0,1.0)   |                       
   |               |                                                         |   12:b,[0.6,1.0)   |   ( 0.6, 1.0, 5, (11,12), 3 )
                                                                           
# a,b die at t=4; sample c,d,e
4  |       a       |       1             1           1              1        |                    | 
   |      / \      |      / \           / \         / \            / \       |                    | 
   |     a   b     |     2   3         2   3       2   3          2   3      |     8:d,[0.0,1.0)  | 
   |    / \ / \    |    / \   \       / \   \     /   / \        /   / \     |     9:c,[0.2,1.0)  | 
   |   a   c   b   |   4   6   3     4   6   3   2   6   5      2   6   5    |    10:c,[0.0,0.2)  | 
   |  / \ /|\ / \  |  /|   |\       /   /|\         /|\            /|  / \   |    11:e,[0.0,1.0)  | 
   | a   d | e   b | 7 8  10 11    4   8 9 11      8 9 11         8 9 11 12  |                    | 
   |    /  |  \    |   |   |  \       /  |  \     /  |  \        /  | |      |                    | 
   |   d   c   e   |   8  10   11    8   9   11  8   9   11     8   9 11     |                    | 
   |               |                                                         |                    | 
   |               |  [0.0,0.2)      [0.2,0.5)    [0.5,0.6)      [0.6,1.0)   |                    | 
   |               |                                                         |                    | 
</code></pre>
<p>What'd we do there? Every time there's a new individual, they get a lineage all to themselves (their whole genome). When anyone has offspring we create new lineages for the parents as well, but only the parts of their genomes inherited by the offspring; these new lineages serve as siblings to their offspring in the new coalescent records.</p>
<p>Here's the order we add and remove records to create the trees in Algorithm T:</p>
<pre><code>   Adding                       |      Removing
1 ( 0.0, 1.0, 1, (2,3),   1 )   |   2 ( 0.0, 0.2, 4, (7,8),   3 )
1 ( 0.0, 0.5, 2, (4,6),   2 )   |   2 ( 0.0, 0.2, 6, (10,11), 3 )
1 ( 0.0, 0.2, 4, (7,8),   3 )   |   3 ( 0.0, 0.5, 2, (4,6),   2 )
1 ( 0.0, 0.2, 6, (10,11), 3 )   |   4 ( 0.2, 0.6, 6, (8,9,11),3 )
2 ( 0.2, 0.6, 6, (8,9,11),3 )   |   * ( 0.6, 1.0, 6, (8,9),   3 )
3 ( 0.5, 1.0, 3, (5,6),   2 )   |   * ( 0.6, 1.0, 5, (11,12), 3 )              
4 ( 0.6, 1.0, 6, (8,9),   3 )   |   * ( 0.5, 1.0, 3, (5,6),   2 )
4 ( 0.6, 1.0, 5, (11,12), 3 )   |   * ( 0.0, 1.0, 1, (2,3),   1 )                        </code></pre>
</body>
</html>
